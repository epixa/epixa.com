<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>A Simple Alternative to Global Registry Dependency</title>
  <meta name="description" content="Anyone that has written object oriented code has had to use one class from within another class.  The quick and dirty way to implement this is to simply hard...">

  <link rel="canonical" href="/2010/12/a-simple-alternative-to-global-registry-dependency.html">
</head>


  <body>

    <div class="content page row">

      <article class="document col" itemscope itemtype="http://schema.org/BlogPosting">

  <header>
    <h1 itemprop="name headline">A Simple Alternative to Global Registry Dependency</h1>
    <h2><time datetime="2010-12-06T12:03:12-05:00" itemprop="datePublished">December 2010</time></h2>
  </header>

  <section itemprop="articleBody">
    <p>Anyone that has written object oriented code has had to use one class from within another class.  The quick and dirty way to implement this is to simply hardcode the object instantiation within the current class, but this can cause you more hassle in the long run.  Unfortunately, this method provides you with no means of overriding or changing that dependency on the fly, so future modifications and testing suffer.</p>

<p>The obvious solution to this hard-coding issue is to instead rely on objects being explicitly passed via a constructor and/or mutators.  If your service requires a database adapter, create a <strong>setDbAdapter()</strong> method and whenever you instantiate a new service object, pass in the adapter.  This solution provides an incredible amount of flexibility, but it does force you to set an adapter on every single service instantiation.  For most applications, only one database adapter will ever be required, so it is tedious at best to pass in the adapter to each and every service.</p>

<p>This is where many developers (and frameworks) turn to a global registry.  During the bootstrap process, they will configure a database adapter and store it in a singleton registry, and then their service object would retrieve the adapter from the registry.  This gives you flexibility when configuring and setting your adapter, and it allows you to instantiate a new service without having to explicitly set commonly used dependencies, but you are ultimately just replacing one hardcoded object call with another.  This means you are still limited in your ability to unit test the class properly, and you will have a difficult time debugging if you ever need to find out exactly when and where your database adapter was configured.</p>

<h2 id="the-simple-solution">The Simple Solution</h2>
<p>Use static methods to set a default database adapter for all services that need it but still allow database adapters to be set explicitly.  In your bootstrap process, you configure your database adapter just like you would normally, then you set the adapter as the “default” adapter for all services.  The service should have a <strong>getDbAdapter()</strong> method that pulls either the adapter set on that instance or, if there is no adapter set, it uses the default adapter instead.</p>

<p>This is what your abstract service could look like (adapted from my <a href="https://github.com/epixa/Epixa/blob/master/library/Epixa/Service/AbstractDoctrineService.php">doctrine2 entity manager service</a>):</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">Epixa\\Service</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Epixa\\Exception\\ConfigException</span><span class="p">,</span>
    <span class="nx">Zend_Db_Adapter_Abstract</span> <span class="k">as</span> <span class="nx">DbAdapter</span><span class="p">;</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractDbService</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="nv">$dbAdapter</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="k">protected</span> <span class="k">static</span> <span class="nv">$defaultDbAdapter</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>


    <span class="sd">/**
     * Set the default database adapter for all database services
     *
     * @param DbAdapter $dbAdapter
     */</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">setDefaultDbAdapter</span><span class="p">(</span><span class="nx">DbAdapter</span> <span class="nv">$dbAdapter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">self</span><span class="o">::</span><span class="nv">$defaultDbAdapter</span> <span class="o">=</span> <span class="nv">$dbAdapter</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**
     * Get the default database adapter for all database services
     *
     * @return DbAdapter
     * @throws ConfigException If no default database adapter is set
     */</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getDefaultDbAdapter</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$defaultDbAdapter</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">ConfigException</span><span class="p">(</span><span class="s1">'No default database adapter configured'</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$defaultDbAdapter</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**
     * Set the database adapter for this service
     *
     * @param  DbAdapter $dbAdapter
     * @return AbstractDbService *Fluent interface*
     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">setDbAdapter</span><span class="p">(</span><span class="nx">DbAdapter</span> <span class="nv">$dbAdapter</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dbAdapter</span> <span class="o">=</span> <span class="nv">$dbAdapter</span><span class="p">;</span>

        <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="sd">/**
     * Get the database adapter for this service
     *
     * If no database adapter is set, set it to the default database adapter.
     *
     * @return DbAdapter
     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getDbAdapter</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dbAdapter</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">setDbAdapter</span><span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="na">getDefaultDbAdapter</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">dbAdapter</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Then, in your bootstrap, you would just need to set the default adapter:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

<span class="k">use</span> <span class="nx">Epixa\\Application\\Bootstrap</span> <span class="k">as</span> <span class="nx">BaseBootstrap</span><span class="p">,</span>
    <span class="nx">Epixa\\Service\\AbstractDbService</span> <span class="k">as</span> <span class="nx">DbService</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Bootstrap</span> <span class="k">extends</span> <span class="nx">BaseBootstrap</span>
<span class="p">{</span>
    <span class="sd">/**
     * Set the default database adapter for database services
     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">_initDbServices</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$db</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bootstrap</span><span class="p">(</span><span class="s1">'db'</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">getResource</span><span class="p">(</span><span class="s1">'db'</span><span class="p">);</span>
        <span class="nx">DbService</span><span class="o">::</span><span class="na">setDefaultDbAdapter</span><span class="p">(</span><span class="nv">$db</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This code is adhering to Zend Framework’s bootstrapping implementation, but the premise is universal: set up your database adapter, and set it as the default on the abstract service.  After that is done, any class that extends AbstractDbService will have access to the database adapter.  However, if they needed to have their own database adapter set (either for unit testing purposes or if they happened to need to access another database), you can do so on an individual basis.  In either case, the way you access the database adapter within your service remains unchanged.</p>

<p>And that’s it!  Go ahead and mock your dependencies for unit testing or throw around different database adapters at your pleasure.</p>

<p>Ok, ok…  That isn’t entirely it.</p>

<h2 id="there-is-one-large-caveat">There is One Large Caveat</h2>
<p>If your objects rely on a large [variable] number of dependencies, a single abstract class might not do the trick.  My services generally do not require more than an entity manager and an ACL object, and I imagine many developers will be in a similar boat.  That said, this is not the best solution out there for handling a lot of dependencies.  If this is not sufficient for your needs, consider a more robust system such as <a href="http://components.symfony-project.org/dependency-injection/">Symfony’s dependency injection framework</a>.</p>

<h2 id="a-final-note">A Final Note</h2>
<p>With the addition of <a href="http://wiki.php.net/rfc/horizontalreuse">traits</a> in the PHP trunk, this method of setting defaults for dependencies will actually be that much more powerful.  Instead of having to deal with a single abstract class, each dependency can be managed by a single trait, and your objects will be able to pick and choose whichever traits they need.  Neat, eh?</p>


  </section>

</article>


    </div>

  </body>

</html>
