<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Organize Your Project like a Pro with PHP Namespaces</title>
  <meta name="description" content="PHP took a huge step forward in June 2009 with the release of version 5.3.  It wasn’t quite as big of a change as version 5.0, but the release did introduce ...">

  <link rel="canonical" href="/2010/04/organize-your-project-like-a-pro-with-php-namespaces.html">
</head>


  <body>

    <div class="content page row">

      <article class="document col" itemscope itemtype="http://schema.org/BlogPosting">

  <header>
    <h1 itemprop="name headline">Organize Your Project like a Pro with PHP Namespaces</h1>
    <h2><time datetime="2010-04-16T20:51:26-04:00" itemprop="datePublished">April 2010</time></h2>
  </header>

  <section itemprop="articleBody">
    <p>PHP took a huge step forward in June 2009 with the release of version 5.3.  It wasn’t quite as big of a change as version 5.0, but the release did introduce a number of new language features including <a href="http://php.net/namespace">namespaces</a> – an addition that can dramatically improve the way you organize your PHP in an object oriented paradigm.</p>

<p>Anyone who’s written code in Java, C++, or for any language in ASP.NET has had the pleasure of working with them, but we PHP developers have had to settle with emulating namespaces by defining long class prefixes.</p>

<p>Prefixes serve their primary purpose well: when used correctly, they will ensure that your class names do not have naming conflicts.  Unfortunately, they are long and pedantic, and provide no additional benefits.  Take, for example, the following class name: <em>Zend_Service_DeveloperGarden_Response_ConferenceCall_CreateConferenceResponseType</em> which can be found in <a href="http://framework.zend.com">Zend Framework</a>.  At 81 characters, the name of this class by itself breaks the <a href="http://framework.zend.com/manual/en/coding-standard.php-file-formatting.html#coding-standard.php-file-formatting.max-line-length">recommended line length</a> in Zend’s own coding standard, and it is not even the longest class name in the framework!</p>

<p>Namespaces provide other benefits than shorter class names, though.  Consider the following:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>
<span class="k">namespace</span> <span class="nx">Epixa\Service</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Epixa\Model\ArticleModel</span><span class="p">,</span>
    <span class="nx">Epixa\Model\AuthorModel</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ArticleService</span> <span class="k">extends</span> <span class="nx">AbstractService</span>
<span class="p">{</span>
    <span class="sd">/**
     * @param  string      $title
     * @param  AuthorModel $author
     * @return ArticleModel
     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">create</span><span class="p">(</span><span class="nv">$title</span><span class="p">,</span> <span class="nx">AuthorModel</span> <span class="nv">$author</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$article</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArticleModel</span><span class="p">();</span>
        <span class="nv">$article</span><span class="o">-&gt;</span><span class="na">title</span> <span class="o">=</span> <span class="nv">$title</span><span class="p">;</span>
        <span class="nv">$article</span><span class="o">-&gt;</span><span class="na">author</span> <span class="o">=</span> <span class="nv">$author</span><span class="p">;</span>
        <span class="k">return</span> <span class="nv">$article</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The namespace declaration immediately gives you a clear indication of what type of class is being declared – a service within the Epixa library.</p>

<p>Along with simply declaring a namespace, the file then uses other namespaces.  In this particular case, I chose to import the specific classes ArticleModel and AuthorModel.  I could have simply used the Epixa\Model namespace, and then I would be able to instantiate any models within the namespace, but importing the specific models that I plan to use is a clear way to define class dependencies.</p>

<p>At this point, we haven’t even declared the class, yet we already know what type of class it will be and what dependencies it will have.  Throughout the rest of the class declaration and definition, the concise class names are used.  Long, ugly prefixes are left in the dust, and the code is cleaner and clearer as a result.</p>

<h2 id="but-court-itll-be-forever-until-the-community-adopts-php-53">But Court, it’ll be <em>forever</em> until the community adopts PHP 5.3!</h2>
<p>While this sentiment might have been true for past releases of PHP, developers finally seem to be coming around to the notion that software drives the community forward.  When software increases its requirements, server administrators <em>will</em> follow suit.</p>

<p>In less than a year, industry-leading frameworks such as <a href="http://framework.zend.com/wiki/display/ZFDEV2/Zend+Framework+2.0+Roadmap">Zend Framework</a> and <a href="http://www.symfony-project.org/blog/2009/10/27/why-will-symfony-2-0-finally-use-php-5-3">Symfony</a> have decided to utilize these new features to such an extent that 5.3 will be a minimum requirement.  The Doctrine team is well into its development roadmap which includes a new <a href="http://www.doctrine-project.org/documentation/manual/2_0/en/introduction#requirements">minimum requirement of PHP 5.3</a>; they have already slated an <a href="http://www.doctrine-project.org/blog/doctrine-future-roadmap">end-of-life date</a> for their 1.x branch and are taking the release of PHP 5.3 not as a challenge but as an opportunity to radically improve their codebase.</p>

<p>Don’t be left in the dust; the PHP community is moving forward with version 5.3, and an <a href="http://www.php.net/manual/en/migration53.incompatible.php">easy upgrade path</a> means you can start benefiting from incredible language features such as namespaces immediately.</p>


  </section>

</article>


    </div>

  </body>

</html>
